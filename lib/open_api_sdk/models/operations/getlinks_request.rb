# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module OpenApiSDK
  module Models
    module Operations
    

      class GetLinksRequest
        extend T::Sig
        include Crystalline::MetadataFields

        # The domain to filter the links by. E.g. `ac.me`. If not provided, all links for the workspace will be returned.
        field :domain, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'domain', 'style': 'form', 'explode': true } }
        # Deprecated: Use `tagIds` instead. The tag ID to filter the links by.
        field :tag_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'tagId', 'style': 'form', 'explode': true } }
        # The tag IDs to filter the links by.
        field :tag_ids, Crystalline::Nilable.new(Crystalline::Union.new(::String, Crystalline::Array.new(::String))), { 'query_param': { 'field_name': 'tagIds', 'style': 'form', 'explode': false } }
        # The unique name of the tags assigned to the short link (case insensitive).
        field :tag_names, Crystalline::Nilable.new(Crystalline::Union.new(::String, Crystalline::Array.new(::String))), { 'query_param': { 'field_name': 'tagNames', 'style': 'form', 'explode': false } }
        # The folder ID to filter the links by.
        field :folder_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'folderId', 'style': 'form', 'explode': true } }
        # The search term to filter the links by. The search term will be matched against the short link slug and the destination url.
        field :search, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'search', 'style': 'form', 'explode': true } }
        # The user ID to filter the links by.
        field :user_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'userId', 'style': 'form', 'explode': true } }
        # The ID of the tenant that created the link inside your system. If set, will only return links for the specified tenant.
        field :tenant_id, Crystalline::Nilable.new(::String), { 'query_param': { 'field_name': 'tenantId', 'style': 'form', 'explode': true } }
        # Whether to include archived links in the response. Defaults to `false` if not provided.
        field :show_archived, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'showArchived', 'style': 'form', 'explode': true } }
        # DEPRECATED. Filter for links that have at least one tag assigned to them.
        field :with_tags, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'query_param': { 'field_name': 'withTags', 'style': 'form', 'explode': true } }
        # The field to sort the links by. The default is `createdAt`.
        field :sort_by, Crystalline::Nilable.new(Models::Operations::SortBy), { 'query_param': { 'field_name': 'sortBy', 'style': 'form', 'explode': true } }
        # The sort order. The default is `desc`.
        field :sort_order, Crystalline::Nilable.new(Models::Operations::SortOrder), { 'query_param': { 'field_name': 'sortOrder', 'style': 'form', 'explode': true } }
        # DEPRECATED. Use `sortBy` instead.
        field :sort, Crystalline::Nilable.new(Models::Operations::Sort), { 'query_param': { 'field_name': 'sort', 'style': 'form', 'explode': true } }
        # The page number for pagination.
        field :page, Crystalline::Nilable.new(::Float), { 'query_param': { 'field_name': 'page', 'style': 'form', 'explode': true } }
        # The number of items per page.
        field :page_size, Crystalline::Nilable.new(::Float), { 'query_param': { 'field_name': 'pageSize', 'style': 'form', 'explode': true } }

        sig { params(domain: T.nilable(::String), tag_id: T.nilable(::String), tag_ids: T.nilable(T.any(::String, T::Array[::String])), tag_names: T.nilable(T.any(::String, T::Array[::String])), folder_id: T.nilable(::String), search: T.nilable(::String), user_id: T.nilable(::String), tenant_id: T.nilable(::String), show_archived: T.nilable(T::Boolean), with_tags: T.nilable(T::Boolean), sort_by: T.nilable(Models::Operations::SortBy), sort_order: T.nilable(Models::Operations::SortOrder), sort: T.nilable(Models::Operations::Sort), page: T.nilable(::Float), page_size: T.nilable(::Float)).void }
        def initialize(domain: nil, tag_id: nil, tag_ids: nil, tag_names: nil, folder_id: nil, search: nil, user_id: nil, tenant_id: nil, show_archived: true, with_tags: true, sort_by: Models::Operations::SortBy::CREATED_AT, sort_order: Models::Operations::SortOrder::DESC, sort: Models::Operations::Sort::CREATED_AT, page: 1.0, page_size: 100.0)
          @domain = domain
          @tag_id = tag_id
          @tag_ids = tag_ids
          @tag_names = tag_names
          @folder_id = folder_id
          @search = search
          @user_id = user_id
          @tenant_id = tenant_id
          @show_archived = show_archived
          @with_tags = with_tags
          @sort_by = sort_by
          @sort_order = sort_order
          @sort = sort
          @page = page
          @page_size = page_size
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @domain == other.domain
          return false unless @tag_id == other.tag_id
          return false unless @tag_ids == other.tag_ids
          return false unless @tag_names == other.tag_names
          return false unless @folder_id == other.folder_id
          return false unless @search == other.search
          return false unless @user_id == other.user_id
          return false unless @tenant_id == other.tenant_id
          return false unless @show_archived == other.show_archived
          return false unless @with_tags == other.with_tags
          return false unless @sort_by == other.sort_by
          return false unless @sort_order == other.sort_order
          return false unless @sort == other.sort
          return false unless @page == other.page
          return false unless @page_size == other.page_size
          true
        end
      end
    end
  end
end
